

## Spring Cloud Stream 工作原理

![](/pic/SpringCloudStream.png)

- RabbitMQ

引入包
```xml
 <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
```
1. 消息的发送者

配置
```yml
spring:
  cloud:
    stream:
      binders: # 这是一组binder的集合，这里配置了一个名为defaultRabbit的binder，这个binder中是包含了一个rabbit的连接信息
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: 10.0.20.132
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 这里配置了一个名为output的binding，这个binding中配置了指向defaultRabbit的binder下的一个交换机studyExchange
        output: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
定义消息发送接口
```java
public interface IMessageProvider {

    /**
    * 实现消息的发送，本次发送的消息是一个对象（自动变为json）
    * @param company VO对象，该对象不为null*/
      public void send(Company company) ;
}

@EnableBinding(Source.class) // 可以理解为是一个消息的发送管道的定义
public class MessageProviderImpl implements IMessageProvider {
    @Resource
    private MessageChannel output; // 消息的发送管道

    @Override
    public void send(Company company) {
        this.output.send(MessageBuilder.withPayload(company).build()); // 创建并发送消息
    }
}

public interface Source {
    String OUTPUT = "output"; // 之前所设置的消息发送的管道

    @Output(Source.OUTPUT)
    MessageChannel output();
}
```
测试用例：
```java
public class TestMessageProvider {
    @Resource
    private IMessageProvider messageProvider;

    @Test
    public void testSend() {
        Company company = new Company();
        company.setTitle("studyjava");
        company.setNote("更多资源请登录：www.study.cn");
        this.messageProvider.send(company); // 消息发送
    }
}
```

启动 RabbitMQ 以及相应的微服务进行消息的发送处理，如果可以检测到 RabbitMQ 上的活动信息就表示该微服务创建成功

2. 消息的接收者

```yml
spring:
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: 10.0.20.132
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```

消息监听
```java
@Component
@EnableBinding(Sink.class)
public class MessageListener {
    @StreamListener(Sink.INPUT)
    public void input(Message<Company> message) {
        System.err.println("【*** 消息接收 ***】" + message.getPayload());
    }
}

public interface Sink {

    String INPUT = "input";

    @Input(Sink.INPUT)
    SubscribableChannel input();

}


```

3. 自定义消息通道
```java
public interface DefaultProcess {
    public static final String OUTPUT = "study_output"; // 输出通道名称
    public static final String INPUT = "study_input"; // 输入通道名称

    @Input(DefaultProcess.INPUT)
    public SubscribableChannel input();

    @Output(DefaultProcess.OUTPUT)
    public MessageChannel output();
}
```
```yml
spring:
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: rabbitmq-server
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        study_output: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
```yml
bindings: # 服务的整合处理
    study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
        destination: studyExchange # 表示要使用的Exchange名称定义
        content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
        binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
```java
@EnableBinding(DefaultProcess.class) // 可以理解为是一个消息的发送管道的定义
public class MessageProviderImpl implements IMessageProvider {
    @Resource
    private MessageChannel output; // 消息的发送管道

    @Override
    public void send(Company company) {
        this.output.send(MessageBuilder.withPayload(company).build()); // 创建并发送消息
    }
}

@Component
@EnableBinding(DefaultProcess.class)
public class MessageListener {
    @StreamListener(Sink.INPUT)
    public void input(Message<Company> message) {
        System.err.println("【*** 消息接收 ***】" + message.getPayload());
    }
}

```

- 分组与持久化
所发送的消息在默认情况下它都属于一种临时消息，也就是说如果现在没有消费者进行消费处理，那么该消息是不会被保留的。
 如果要想实现持久化的消息处理，重点在于消息的消费端配置，同时也需要考虑到一个分组的情况（**有分组就表示该消息可以进行持久化**）

```yml
bindings: # 服务的整合处理
    study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
        destination: studyExchange # 表示要使用的Exchange名称定义
        content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
        binder: defaultRabbit # 设置要绑定的消息服务的具体设置
        group: study-group # 进行操作的分组，实际上就表示持久化

```
在 SpringCloudStream 之中如果要设置持久化队列，则名称为`destination.group`。此时关闭掉消费端的微服务之后该队列信息依然会被保留在 RabbitMQ 之中。而后在关闭消费端的情况下去运行消息生产者，发送完消息后再运行消息的消费端仍然可以接收到之前的消息。

- 设置 RoutingKey
默认情况下之前的程序都是属于广播消息，也就是说所有的消费者都可以接收发送消息内容，在 RabbitMQ 里面支持有直连消息，而直连消息主要是通过 RoutingKey 来实现，利用直连消息可以实现准确的消息消费端的接收处理。
```yml
spring:
  cloud:
    stream:
      rabbit: # 进行rabbit的相关绑定配置
        bindings:
          study_input:
            consumer: # 进行消费端配置
              bindingRoutingKey: study-key # 设置一个RoutingKey信息
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: rabbitmq-server
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: RKExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
          group: study-group # 进行操作的分组，实际上就表示持久化

```

```yml
spring:
  cloud:
    stream:
      rabbit: # 进行rabbit的相关绑定配置
        bindings:
          study_output:
            producer: # 进行消费端配置
              routing-key-expression: '''study-key''' #定义 RoutingKey 的表达式配置
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
```



## RabbitMQ
rabbitmq中的几个重要概念
1. 虚拟主机(vhost)

​ 虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。虚拟主机的作用在于进行权限管控，rabbitmq默认有一个虚拟主机"/"。可以使用rabbitmqctl add_vhost命令添加虚拟主机，然后使用rabbitmqctl set_permissions命令设置指定用户在指定虚拟主机下的权限，以此达到权限管控的目的。

2. 消息通道(channel)
在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务

3. 交换机(exchange)
exchange的功能是用于消息分发，它负责接收消息并转发到与之绑定的队列，exchange不存储消息，如果一个exchange没有binding任何Queue，那么当它会丢弃生产者发送过来的消息，在启用ACK机制后，如果exchange找不到队列，则会返回错误。一个exchange可以和多个Queue进行绑定。

交换机有四种类型:
- 路由模式(Direct)："先匹配, 再投送"。即在绑定时设定一个 routing_key, 消息的routing_key 匹配时, 才会被交换器投送到绑定的队列中去。direct是rabbitmq的默认交换机类型。

- 通配符模式(Topic)：​类似路由模式，但是routing_key支持模糊匹配，按规则转发消息（最灵活）。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。

- 发布订阅模式(Fanout)：​转发消息到所有绑定队列，忽略routing_key。

- Headers:  设置header attribute参数类型的交换机。相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型，忽略routing_key。在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列。
​ 在绑定Queue与Exchange时指定一组键值对，当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配。如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。

匹配规则x-match有下列两种类型：
|x-match = all  | 表示所有的键值对都匹配才能接受到消息|
|---------------|----------------------------------|
|x-match = any  |表示只要有键值对匹配就能接受到消息    |






## Spring Cloud Stream 工作原理

![](/pic/SpringCloudStream.png)

- RabbitMQ

引入包
```xml
 <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
```
1. 消息的发送者

配置
```yml
spring:
  cloud:
    stream:
      binders: # 这是一组binder的集合，这里配置了一个名为defaultRabbit的binder，这个binder中是包含了一个rabbit的连接信息
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: 10.0.20.132
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 这里配置了一个名为output的binding，这个binding中配置了指向defaultRabbit的binder下的一个交换机studyExchange
        output: # 这个名字是一个通道的名称
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
定义消息发送接口
```java
public interface IMessageProvider {

    /**
    * 实现消息的发送，本次发送的消息是一个对象（自动变为json）
    * @param company VO对象，该对象不为null*/
      public void send(Company company) ;
}

@EnableBinding(Source.class) // 可以理解为是一个消息的发送管道的定义
public class MessageProviderImpl implements IMessageProvider {
    @Resource
    private MessageChannel output; // 消息的发送管道

    @Override
    public void send(Company company) {
        this.output.send(MessageBuilder.withPayload(company).build()); // 创建并发送消息
    }
}

public interface Source {
    String OUTPUT = "output"; // 之前所设置的消息发送的管道

    @Output(Source.OUTPUT)
    MessageChannel output();
}
```
测试用例：
```java
public class TestMessageProvider {
    @Resource
    private IMessageProvider messageProvider;

    @Test
    public void testSend() {
        Company company = new Company();
        company.setTitle("studyjava");
        company.setNote("更多资源请登录：www.study.cn");
        this.messageProvider.send(company); // 消息发送
    }
}
```

启动 RabbitMQ 以及相应的微服务进行消息的发送处理，如果可以检测到 RabbitMQ 上的活动信息就表示该微服务创建成功

2. 消息的接收者

```yml
spring:
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: 10.0.20.132
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```

消息监听
```java
@Component
@EnableBinding(Sink.class)
public class MessageListener {
    @StreamListener(Sink.INPUT)
    public void input(Message<Company> message) {
        System.err.println("【*** 消息接收 ***】" + message.getPayload());
    }
}

public interface Sink {

    String INPUT = "input";

    @Input(Sink.INPUT)
    SubscribableChannel input();

}


```

3. 自定义消息通道
```java
public interface DefaultProcess {
    public static final String OUTPUT = "study_output"; // 输出通道名称
    public static final String INPUT = "study_input"; // 输入通道名称

    @Input(DefaultProcess.INPUT)
    public SubscribableChannel input();

    @Output(DefaultProcess.OUTPUT)
    public MessageChannel output();
}
```
```yml
spring:
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: rabbitmq-server
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        study_output: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: studyExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
```yml
bindings: # 服务的整合处理
    study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
        destination: studyExchange # 表示要使用的Exchange名称定义
        content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
        binder: defaultRabbit # 设置要绑定的消息服务的具体设置
```
```java
@EnableBinding(DefaultProcess.class) // 可以理解为是一个消息的发送管道的定义
public class MessageProviderImpl implements IMessageProvider {
    @Resource
    private MessageChannel output; // 消息的发送管道

    @Override
    public void send(Company company) {
        this.output.send(MessageBuilder.withPayload(company).build()); // 创建并发送消息
    }
}

@Component
@EnableBinding(DefaultProcess.class)
public class MessageListener {
    @StreamListener(Sink.INPUT)
    public void input(Message<Company> message) {
        System.err.println("【*** 消息接收 ***】" + message.getPayload());
    }
}

```

- 分组与持久化
所发送的消息在默认情况下它都属于一种临时消息，也就是说如果现在没有消费者进行消费处理，那么该消息是不会被保留的。
 如果要想实现持久化的消息处理，重点在于消息的消费端配置，同时也需要考虑到一个分组的情况（**有分组就表示该消息可以进行持久化**）

```yml
bindings: # 服务的整合处理
    study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
        destination: studyExchange # 表示要使用的Exchange名称定义
        content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
        binder: defaultRabbit # 设置要绑定的消息服务的具体设置
        group: study-group # 进行操作的分组，实际上就表示持久化

```
在 SpringCloudStream 之中如果要设置持久化队列，则名称为`destination.group`。此时关闭掉消费端的微服务之后该队列信息依然会被保留在 RabbitMQ 之中。而后在关闭消费端的情况下去运行消息生产者，发送完消息后再运行消息的消费端仍然可以接收到之前的消息。

- 设置 RoutingKey
默认情况下之前的程序都是属于广播消息，也就是说所有的消费者都可以接收发送消息内容，在 RabbitMQ 里面支持有直连消息，而直连消息主要是通过 RoutingKey 来实现，利用直连消息可以实现准确的消息消费端的接收处理。
```yml
spring:
  cloud:
    stream:
      rabbit: # 进行rabbit的相关绑定配置
        bindings:
          study_input:
            consumer: # 进行消费端配置
              bindingRoutingKey: study-key # 设置一个RoutingKey信息
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
              addresses: rabbitmq-server
              username: studyjava
              password: hello
              virtual-host: /
      bindings: # 服务的整合处理
        study_input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明
          destination: RKExchange # 表示要使用的Exchange名称定义
          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”
          binder: defaultRabbit # 设置要绑定的消息服务的具体设置
          group: study-group # 进行操作的分组，实际上就表示持久化

```

```yml
spring:
  cloud:
    stream:
      rabbit: # 进行rabbit的相关绑定配置
        bindings:
          study_output:
            producer: # 进行消费端配置
              routing-key-expression: '''study-key''' #定义 RoutingKey 的表达式配置
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
```

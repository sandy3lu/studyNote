
# 启动
TPM安全芯片首先验证当前底层固件的完整性，如正确则完成正常的系统初始化，然后由底层固件依次验证BIOS和操作系统完整性，如正确则正常运行操作系统，否则停止运行。之后，利用TPM安全芯片内置的加密模块生成系统中的各种密钥，对应用模块进行加密和解密，向上提供安全通信接口，以保证上层应用模块的安全。

TPM会按照整个系统及应用软件栈的装载顺序来监视装载到计算平台上的系统软件及所有应用软件，TPM采用哈希扩展算法，以哈希值特征的形式来存储所有能够被平台装载的全部软件。例如，在X86平台运行过程中，从机器加电启动开始，TPM将按照如下的顺序监视软硬件系统及应用软件栈的装载过程：BIOS、MBR、OS装载器、OS、用户应用程序1-n. TPM将计算平台上的整个软件链的哈希值进行记录，之后就能够把该平台上的软件加载状况向管理中心报告。TPM可以对每个报告进行数字签名，确保报告的真实性
![](pic/tpm-启动.jpg)

# TPM版本1.2 vs 2.0
## 密码算法
TPM 1.2密码算法：RSA加密、RSA签名、RSA-DAA、SHA1、HMAC，并没有要求支持对称算法。

TPM 2.0算法支持：RSA加密和签名、ECC加密和签名、ECC-DAA、ECDH、SHA1、SHA256、HMAC、AES，而且厂商可以随意使用TCG IDs来增加新的算法，如在国内实现必须增加SM2、SM3和SM4算法，拥有一定的灵活性

## 不能只面向PC平台，应该扩展到更加广阔的平台
TPM 1.2主要面向PC平台设计，而类似的安全思维其实可以扩展到网络、服务器、云环境、移动设备和嵌入式产品等。TPM安全芯片本身是以安全芯片的形式在主机上隔离出一个拥有独立处理能力和存储能力的区域，在这个程度上，虚拟技术、TrustZone、智能卡等本质上是一致的，不过安全性可能并不在一个层次。

TPM 1.2的owner只有一个就是用户，而计算平台本身可能也需要使用TPM。TPM 1.2中，所有安全和隐私都在该owner的控制下。TPM 2.0将这种控制功能进行了隔离，给出了三个控制域：安全域或者存储域（owner为用户，用户正常的安全功能）；隐私域（owner为平台或者用户，平台身份认证）；平台域（owner为平台，保护平台固件的完整性）。

如果TPM使用太困难，成本价格太高，又有谁会想去用呢？TPM 1.2在这方面做的并不是很好。一个安全芯片嵌入到服务器上，体现不了多少成本；但是如果在空间有限的移动设备或者嵌入式设备上配备一个安全芯片，基本没太大的价值。因此，TPM 2.0规范主要提供一个参考，以及可能实现的方式，但是并没有限制必须以安全芯片的形式存在，如可以基于虚拟技术或者ARM TrustZone、Intel TXT等进行构建，只要能提供一个可信执行环境（TEE），就可以进行构建。


## 密钥

TPM 1.2的背书密钥只有一个，就是EK，出厂时厂商就预置在芯片内，更换都很困难。takeowner后可以生成属主和唯一的存储根密钥SRK，从而可以构建密钥的存储体系。

在TPM 2.0中，EK属于隐私域，可以有多个，而且可以支持不同的非对称算法；SRK属于安全域，也可以有多个和支持不同的算法。实际上TPM 2.0的三个控制域中，都支持多密钥和多算法。

TPM 2.0的主密钥都是通过主种子，使用密钥派生算法KDF来生成。存储种子的空间比存储密钥的空间要小很多。TPM 2.0中密钥的存储通常是通过对称加密，父密钥的强度不能低于子密钥吧，要不子密钥的安全强度也无法达到其声称的size。

## 平台配置寄存器PCRs

PCRs主要用来存储系统启动和运行过程中的度量值，防止度量日志被篡改。PCRs值不只保证每次系统启动时执行相同的代码，其保证以相同的顺序执行相同的代码。

微软在win8中就使用PCR来恢复unsealing Bitlocker的密钥。如果系统启动过程中有任何微小的变化，都需要用户干预才能恢复，因此这个过程比较脆弱。

TPM 2.0规范运行其有多个PCRs banks，一个bank内所有PCR使用相同的算法进行扩展操作。而且不同的banks可以分配不同的PCRs。对于不同的bank，扩展操作是相互独立的，互不干扰

## 授权

授权即是否允许软件进程访问TPM内部的资源（密钥、计数器、NV存储空间等）。

TPM 1.2拥有不同的机制来授权客体（objects）的使用、委托使用和迁移等。而TPM 2.0提供了一个统一的框架来使用授权功能，授权功能可以通过各种独特的方式进行组合来增加灵活性。

TPM 2.0允许使用明文密码和HMAC的授权，也允许使用多个授权限定符来构造任意复杂的授权策略。增强的授权机制是TPM 2.0的一个特色。

TPM 1.2的授权比较受限制，唯一的授权访问方式是基于passwords和PCR值。例如，为了使用TPM内部的一个密钥，软件需要证明其拥有某个password的知识（通过hash的方式嵌入在可信命令中）；而且可以将该密钥与特定的PCR状态seal在一起。这使得TPM1.2的授权机制缺乏灵活性。通常一个计算机平台拥有多个用户，如何共享TPM密钥和数据是比较困难的。不同用户由于password不一样，他们知道的密钥集合也是相互独立的。系统管理员如何授权这些密钥的使用是一个难点。

TPM 1.2中，软件通过授权会话证明其拥有password（消息验证码），在命令需要授权前通常通过一个独立的命令来开启会话。TPM 2.0提出了增强的授权机制（Enhanced Authorization，EA）。

TPM 2.0对密钥和数据的授权使用方式进行了扩展，授权会话变成了策略会话，多个授权方式可以通过布尔逻辑的形式进行组合。例如，在一个场景中，Alice和Bob两个用户拥有不同的passwords，现在想要让他们可以访问同一个密钥，可以创建一个策略“当且仅当Password(Alice) or Password(Bob),允许访问密钥”。软件进程可以先创建策略，在生成TPM密钥或者数据时指定该策略的哈希值即可，TPM不需要知道策略的详情，hash值足够。

### TPM 2.0的授权方式总结

- Passwords：与TPM 1.2类似

- PCR值：与TPM 1.2一样，不过布尔逻辑加法表示可以使用多个PCR状态

- TPM counter or NVRAM value：需要计数器或者NV空间拥有某个特定值

- Physical presence：需要用户在计算机平台的物理现场

- Commands：客体只能被给定的一组命名使用

- Digital signature from a public key：允许使用外部智能卡来作为授权条件


# 鉴别与认证
- 身份鉴别-你是谁，从诸多可能的对象列表中识别出主体（1对多）
- 认证-你是你所声称的那个人吗(1对1)


## 认证
- 你知道什么：口令 （成本最低）
- 你具有什么：智能卡
- 你是谁：指纹

### 口令
口令+salt，使同一个明文有不同的摘要值，防止前向检索攻击(有人事先算好字典，再比较)。添加salt值的计算与不添加是一样的，salt可以明文，

### 生物特征
理想的生物特征技术应满足以下要素：
- 通用性： 适用于每一个人。实际上，没有哪个生物特征能够应用于所有人，例如，存在少部分的人不具有可读取的指纹。
- 可分辨性：现实中，不能期望100%确定性。
- 永久性：可测量的物理特征应该永久不变，实践中，能够在相当长的一段时间内保持稳定就足够了。
- 可采集性：容易采集，且对认证的主体不会带来任何潜在的伤害。实际上，可采集性往往严重依赖主体是否愿意合作。
- 可靠性、鲁棒性、用户友好性

生物特征的注册过程比较缓慢并需要多次测量，并且在某些现场系统中，采集的结果与在实验室条件下得到的样本很难具有可比性。

- 错误接受率：bob冒充alice，系统错误地将bob认证为alice。
- 错误拒绝率：alice尝试认证她自己，但没有通过。
- 等错误率：对系统参数进行调整，使错误接受率和错误拒绝率能够达到一种恰好平衡的水平。

# 授权
## 橘皮书
《可信计算机系统评估准则》，The Trusted Computing System Evaluation Criteria，又称橘皮书，对安全产品分为4个不同层次：
- D 最小保护：为了对应那些不能够满足更高级别要求的系统。
- C 自主保护： 用户可能会破坏安全性，但是他们的行为可以被捕获。
   - C1 自主安全保护：系统必须提供“能够针对单个人层面施加访问限制的可信赖的控制能力”。
   - C2 受控访问保护：比C1级别中的系统施加更为细粒度的自主访问控制。
- B 强制保护：保护是强制的，用户不能破坏安全性，即使他们想要尝试。
   - B1 标签安全保护：强制访问控制是基于指定标签的。也就是说，所有的数据都携带某些类型的标签，这些标签决定了哪些用户可以访问相应的数据，可以对相应的数据执行什么样的操作。
   - B2 结构化保护：在B1级别上，这个级别增加了隐藏通道保护和少量其他技术特性。
   - B3 安全域：在B2级别之上，实现安全特性的代码必须是“能够防篡改，并且足够小以应对分析和测试”
- A 验证保护：这个层次的要求与B3级别基本相同，除了必须能够有效地运用所谓的形式化方法来证明系统达到了其所声称的安全性。

## CC
如今橘皮书在形式上已经被通用准则Common Criteria所取代。CC认证输出评估保证级别Evaluation Assurance Level，7个级别：
- EAL1-功能测试
- EAL2-结构测试
- EAL3-系统地测试和检查
- EAL4-系统地设计、测试和复查
- EAL5-半形式化地设计和测试
- EAL6-半形式化地验证设计和测试
- EAL7-形式化地验证设计和测试

要想获得EAL7级认证，必须提供安全性的形式化证明，且安全专家们要对产品进行仔细的分析。对于最低级别EAL认证，需要分析的就只是文档而已。最广受欢迎的是EAL4，因为这一般是可以销售给政府的最低要求了。

## 访问控制矩阵（Lampson）
访问控制列表ACL和访问能力列表C-list都源自Lampson的访问控制矩阵。主体S对于客体O的访问许可情况就存储在矩阵中以S为索引的行，与O为索引的列相交的位置上。
![](pic/访问控制矩阵.png)

记账程序既可以看成一个客体，又被当作主体，这样我们就可以强制施加限定条件，使得财务数据仅能由记账程序来修改。

一个系统可能有多个主体以及数万个客体，导致访问控制矩阵记录太多。在执行任何一个主体对客体的操作之前，都需要查阅，处理如此巨大的矩阵会给系统施加显著的负担。

为了在授权操作上获得可接受的性能，有2种直观方式来分割访问控制矩阵：
1. 按列分割，每一列与其对应的客体存储在一起（对客体的控制）。这些列称为`访问控制列表ACL`.
2. 按行分割，每一行与其对应的主体存储在一起（主体的能力），这种方案称为`访问能力列表C-list`。
![](pic/访问控制列表.png)

访问能力列表，用户和文件之间的关联是内建在系统之中的。访问控制列表，需要有单独的方式来建立用户和文件之间的关联关系。

### 混淆代理人
![](pic/混淆代理人.png)
两个资源对象：编译程序、BILL文件。一个用户：Alice。编译程序对所有文件可以执行写操作。Alice可以触发编译程序，并在编译程序写调试信息时指定文件名。不允许Alice对BILL执行写操作。

假设Alice触发编译程序，并想要输出调试信息的文件名为BILL。因为Alice没有权限，这个应该失败，但是编译程序有权限，入根编译程序以它的权限行事，会毁坏BILL。也就是说，编译程序发生了混淆，因为它应该基于Alice的权限工作。

基于访问能力列表比较容易防止这类问题：Alice触发编译程序时，可以将自己的访问能力列表授权给编译程序，于是编译程序在试图创建调试文件时，要先引用Alice的访问能力列表查看权限。

### 访问控制列表vs访问能力列表
- 当用户想要管理自己的文件，并且保护是面向数据的情况下，访问控制列表是更好的选择。
- 访问能力列表容易实现授权机制，以及二级授权、三级授权，且容易实现增加和删除用户。
- 访问能力列表通常实现复杂，且系统符合高，分布式系统中很多难题都是源自这种访问能力列表。因此，访问控制列表在实践中的应用要多。


## 多级安全性Multilevel Security
在大部分的公司业务管理中，都有一类信息是受严格限制（供高级管理层），而另外一些信息则是供全体管理层访问，同时还有信息共享给所有人。如果这些信息被存储在单一系统中，那么公司必须要解决多级安全性问题。

美国国防部定义4级： TOP SECRET>SECRET>CONFIDENTIAL>UNCLASSIFIED
主体S的安全等级表示为L(S)，客体O的安全等级表示为L(O)。

### Bell-LaPadula模型-针对机密性
- 简单安全条件：
不许向上读：主体S能够对客体O执行读操作，当且仅当L(O)<=L(S)。Alice不能够读取一个文档，如果她缺乏相应的权限。

- 星特性：
不许向下写：主体S能够对客体O执行写操作，当且仅当L(S)<=L(O)。要防止Top secret级别的信息被写入secret级别的文档。

### Biba-针对完整性
客体O的完整性等级是所有包含于O中客体完整性等级最小值。
- 写访问原则：主体S能对客体O执行写操作，当且仅当I(O)<=I(S)。我们对主体所写的内容的新人程度，不会超过我们对S自身的信任程度。
- Biba模型：主体S能对客体O执行读操作，当且仅当I(s)<=I(o)。我们对主体S的信任不应超过S所读取的客体的最低完整性级别。本质上说，我们的顾虑是S将被更低完整性级别的客体“弄脏”，所以要禁止S查看这样的客体。
- 低水印策略：如果主体S对客体O执行了读，那么I(s)=min(I(s),I(o)).

![](pic/BLP.png)


## 分隔项 compartment
使用分隔项来进一步限定信息流所“跨越”的安全级别。分隔项主要是用于强化必须知情原则，也就是说，只有当主体因工作需要必须了解某个信息时，才能允许其访问。

例如：分隔项 TOP SECRET{CAT}和TOP SECRET{DOG}。虽然都是TOP SECRET级别，但是一个具有TOP SECRET级别的主体只有在经过特殊许可的情况下，才能对分隔项进行访问。

## 隐藏通道
隐藏通道的成立，要有3个条件：
- 发送方和接受方有一个共享的资源。
- 发送方必须能以接受方能察觉到的方式改变共享资源的某些属性。
- 发送方和接受方能实现通信的同步。

在任何一个有用的系统中，想要消除掉所有的隐藏通道实际上时不可能的。

例子：
TCP协议头，包含一个预留的字段以供未来的用途，可以被用于秘密地传递信息。

## CAPTCHA
completely automated public Turing test to tell computers and humans apart,完全自动化的公开的图灵测试，其目标是将计算机和人区别开来，

CAPTCHA的设计目标就是防止非自然人访问资源对象，也可以视作一种访问控制的形式。免费邮件系统服务使用CAPTCHA来防止垃圾邮件发送者为大量的电子邮件账户进行自动订阅。

## 防火墙
简单的防火墙只过滤一些明显的伪造请求。

### 端口扫描攻击
- TCP ACK扫描--
攻击者构造一个数据包，并设置ACK位，从而跳过TCP三次握手的前2个步骤。由于包过滤防火墙没有状态的概念，会认为这个包是某个已经建立的连接的一部分，于是，只要该数据包发往一个开放的端口，防火墙就会让其通行。主机发现这个数据包不是已经建立连接的一部分，响应一个RST包。

- Firewalk检测工具--
存活生命期TTL是IP数据包头的一个字段，包含了数据包在终止之前可以被转发的跳数。如果攻击者知道防火墙IP、内部网络上某个系统的IP，还知道从该系统到防火墙的跳数，那么，她可以向内部网络IP上发数据包，TTL设置为比到防火墙的跳数大1，假如防火墙让数据包在端口p上通行，攻击者会受到超时错误。


### 包过滤防火墙
在网络层上对数据包进行检查。根据在网络层可用的信息进行数据包的过滤，包括源IP地址、目的IP地址、源端口、目的端口、TCP标志位。能够对进入的数据包和发出的数据包分别指定不同的过滤规则。

- 包过滤防火墙的主要优势是性能好，仅仅处理网络层，也只有包头信息会被检查。
- 没有状态的概念，每个数据包的处理是独立的，也就是对应用数据是没有感知的。
- 使用访问控制列表ACL进行配置。
![](pic/防火墙.png)


### 基于状态检测的包过滤防火墙
在普通包过滤防火墙的基础上增加状态管理，能够跟踪TCP连接，并且能记忆UDP连接。从概念上讲，基于状态检测的包过滤防火墙工作在传输层。

可以防止TCP ACK攻击。不足是不能检查应用数据。

### 应用代理防火墙
对数据包一路分析到应用层。应用代理有能力在应用层过滤掉恶意数据（比如病毒），同时也能够在传输层过滤掉恶意的数据。

应用代理在数据包通过防火墙时，会毁弃进来的数据包并在同样的位置创建一个新的数据包。应用代理可以阻止Firewalk。

### 深度防御的例子
![](pic/深度防御.png)

- 包过滤防火墙被置于停火区（DMZ），用于防御对系统的常规性攻击。置于DMZ区的部分都是一些必须暴露给外部的应用，要接收来自外部的大部分流量，从性能考虑，使用简单的包过滤防火墙。
- 一台应用代理防火墙部署在内部网络和DMZ之间，为内部网络提供了最大可能性的防火墙保护措施。进入到内部网络的流量相对比较小，所以部署一台应用代理不会构成瓶颈。
- 最后一层防护，个人防火墙可以被部署在公司内部网络中的特定主机上。

## 入侵检测系统 Instrusion detection System
计算机安全的主要认为是入侵防御，但是当防御失败时，需要检测系统，在攻击发生之前、期间、之后，检测出这些攻击。

IDS的基本方法时查看“异常”活动，自动化入侵检测实际上时人工日志文件分析的发展。

入侵响应：一旦检测有入侵，就要做成响应。比如检测到针对某个特定账户的口令猜测攻击，可以锁定该账户来做出响应。
### 方法
- 基于特征的IDS：基于明确的已知特征来检测。例如：“M秒种之内发生N次登录尝试失败”定义为攻击的一个特征。
  - 优势是简单、高效，以及优秀的检测已知攻击的能力，能发出明确的报警。
  - 劣势是特征文件必须足够新，特征数量太多会造成性能下降。只能检测已知类型的攻击。已知攻击的轻微变体可能会被错过。

- 基于异常的IDS：先给系统的正常行为一个基线，当系统行为与基线偏差过大，IDS报警。
  - 首先要确定对于系统来说，正常的行为都包括什么。
  - 其次，随着系统使用方法的变化和系统自身的演化，这些正常行为的定义必须做调整
  - 统计门限的设定
  - 异常行为引发的报警可能提供不了对管理员有用的具体信息。
  - 优势是有可能检测出之前不知道的攻击。

### 架构
- 基于主机的IDS：入侵检测的方法应用于发生在主机上的活动中，对于主机上可见的攻击（缓冲区溢出攻击、权限提升类攻击）的检测有优势。
- 基于网络的IDS：应用在网络流量上，类似拒绝服务攻击、端口扫描、涉及畸形数据包的检测。与防火墙的功能有所重叠。

# 零知识证明
公钥技术的运用使得参与者难以保持匿名的身份。零知识证明的一个优势是允许以匿名的方式进行身份认证。

## Bob洞穴问题
Alice声称她知道秘密的暗语，能够打开R和S之间的那扇门。Alice怎么说服Bob相信她知道这个秘密暗语，又不会泄露相关信息。

![](pic/洞穴问题.png)
Alice进入洞穴，抛硬币决定去R或是S点，假设Alice到了R点，然后Bob进入洞穴到Q点。Bob抛硬币决定让Alice从哪里出现。如果Bob碰巧也是R，则Alice无论是否知道谜语，都可以出现。如果Bob选择了S，那么Alice必须知道开门暗语才能出现在S侧。也就是说，如果Alice不知道暗语，那么骗过Bob的概率是0.5。如果重复n次，例如20次，那么这个概率会小于1000000分之一。这里最关键的是，Bob随机选择其中一侧。

## Fiat-Shamir协议
数学依赖：求解模N的平方根，其难度与因式分解相当。假设N=pq，其中p和q都是素数。Alice知道一个秘密S。`N 和 v=S^2 mod N 公开`(从N和v计算出S很难)。Alice说服bob相信她知道S。
![](pic/Fiat-Shamir.png)
第二条消息，如果bob发送e=1,则Alice必须知道S。如果e=0，则Alice不必知道S。

第1条消息属于提交阶段，Alice发送给Bob的r值的选择。也就是说Alice不能改变主意，另外也没有泄露r值，因为求模平方根的运算很困难。
第2条消息是challenge，即Bob要求Alice提供正确的响应。
第3条消息是response。

如果攻击者能预测到e=1，那么可以在第1条消息发x = r^2 v^-1 mod N，第3条发y=r mod N。而Bob会发现等式9.1成立。所以要随机发e=0,1。经过n次迭代，攻击者瞒天过海的概率0.5^n。

另外，Alice必须每次都随机生成r，否则S会被泄露。

# Secure Shell协议（SSH）
SSH创建了一个安全通道，基于该通道，可以安全的方式执行原本不安全的命令。SSH提供了机密性和完整性保护。
![](pic/SSH.png)
- 第1条消息里，Alice表明自己的身份，并将其希望采用的加密参数等相关信息CP，以及她的nonce值Ra发送过去。
- 第2条消息里，Bob从Alice的选择中做出选择CS，并发送自己的nonce值Rb。
- 第3条消息里，Alice发送她的Diffie-Hellman值
- 第4条消息里，Bob发送他的Diffie-Hellman值、他的数字证书，以及对H消息的签名值Sb
- 最后一条，Alice计算密钥K，发送一个加密的数据包，包括了她的身份、数字证书、签名值Sa。

![](pic/SSH-1.png)

# IPSec（Internet Protocol Security）
IPSec运行在网络层，不能从用户空间直接访问，处于操作系统运行的范畴。IPSec常用于提供对VPN的保护，另外IPSec也是IPv6的要求之一。
IPSec协议的2个主要组成：
- Internet密钥交换协议（IKE）：双向交互认证和会话密钥
- 封装安全有效载荷和认证头（Encapsulating Security Payload 和 Authentication Header）：ESP提供IP数据包的加密和完整性保护，AH只提供完整性保护。
## IKE
### 数字签名模式
![](pic/IKE.png)
![](pic/IKE-1.png)

![](pic/IKE-2.png)
主模式和积极模式的差别：在主模式中，有可能将g和p作为CP和CS的一部分进行协商，积极模式中不能协商。主模式是必须实现的。

### 对称密钥方式
![](pic/IKE-3.png)

### 公开密钥加密方式
![](pic/IKE-4.png)

### IPSec cookie（抗阻塞令牌）
在IPSec协议中，cookie的既定目标是令拒绝服务攻击DoS更加困难。

TCP SYN flooding攻击：每个TCP SYN请求都将引发服务器执行少量的计算任务（比如创建SEQ号）并保持若干状态。也就是，服务器必须记住所谓的半开连接，以便3次握手中第3个步骤所返回的相应ACK到达时，能够完成该连接的建立。如果攻击者使用数目庞大的SYN数据包对一台服务器进行狂轰滥炸，服务器终将会耗尽自己的资源。

在IPSec协议中，为了降低DoS攻击，服务器倾向于尽可能不保持状态，IPSec的cookie是用来帮服务器保持无状态的。但是显然并没有达到设计目标。在每一种协议的主模式中，服务器从第1条开始记录加密方案提议和CP，也就是从第1条就开始保持状态。


## ESP 和 AH
ESP头或者AH头被包含在具备IPSec保护的数据报中，这个头信息会告诉接收方，这不是标准的IP数据报，而是要按照ESP或者AH数据包的方式处理。

### 运输和隧道方式
- 运输方式：一个新的ESP/AH头被插入到IP数据包头和数据内容之间，原始的IP数据包头保持不变。弱点是，攻击者可以看到IP数据包头
![](pic/运输方式.png)

- 隧道方式：整个原始的IP包都被封装到一个新的IP包当中。优点是，原始的IP数据包头对攻击者不可见。但是，如果Alice和Bob是直接进行沟通，那么新的IP数据包头将与被封装的IP数据包头相同。假定IPSec封装在防火墙之间启用，在采用隧道方式下，新的IP数据包头信息只会揭示出在Alice的防火墙和Bob的防火墙之间传输，攻击者不会知道防火墙之后的哪个或哪些特定主机在进行通信。
![](pic/隧道方式.png)

### AH
AH认证头的完整性保护可以用来保护的信息包括除了IP数据包头之外的所有信息，另外IP数据包`头信息中的某些字段也可以获得AH认证头的保护`。AH将IP数据包头字段分为可变和不可变，将完整性保护施加到所有不可变字段上。


### ESP
ESP的机密性和完整性保护可以施加于除IP数据包头之外的所有信息上，不包括IP数据包头信息。

# Kerberos
Kerberos的设计面向比较小规模的应用场景，类似局域网LAN，或者是公司内部网络等环境。

场景：假设N个用户，要求能两两相互认证对方。如果基于公开密钥加密方案，每个用户需要一对公私钥。通过依赖于可信任的第三方Trusted Third Party（被称为密钥分发中心）, Kerberos方案只需要N个对称密钥，而且用户之间不用共享密钥。取而代之的是每一个用户与KDC之间共享密钥，KDC扮演中间人的角色，保证任何一对用户彼此间能安全通信。

KDC负责签发各种类型的票据ticket，票据中包含了密钥以及其他一些访问网络资源所需要的信息。一种特殊的票据——票据许可票据Ticket-Granting Ticket，TGT，在用户初始登陆系统时签发，作为用户凭证，用户可以凭借TGT来获取普通的票据，以便能访问网络资源。对于Kerberos协议的无状态性，TGT票据是其中至关重要的设计。

TGT票据包含会话密钥、票据的签发目标用户、有效期。TGT票据由KDC的密钥Kkdc加密，也就是只有KDC才能读取。这样，KDC就不需要维护用户及其会话密钥的数据库了。

## Kerberos化的登陆
Alice输入用户名和口令，Alice的计算机利用输入的口令计算除密钥Ka，这个Ka是Alice和KDC共享的密钥。Alice的计算机利用Ka从KDC处获取Alice的TGT票据（为了安全，计算机会丢弃Ka）。接下来Alice就可以使用她的TGT票据进行对网络资源的安全访问了。
![](pic/Kerberos.png)

## Kerberos中的票据
Alice想与Bob沟通，首先Alice的计算机将Alice的TGT票据提交给KDC，同时还有认证码，这个认证码是加密的时间戳，主要目的是避免重放。KDC验证了Alice的认证码之后，会返回包含了“需要提交给Bob的票据ticket to Bob”。
![](pic/Kerberos-1.png)

Alice的计算机用这个与Bob的计算机进行安全通信。
![](pic/Kerberos-2.png)

Kerberos认证框架中，时钟偏差默认是5分钟。（所有时钟不能保证完美同步）

## Kerberos安全性
为什么“需要提交给Bob的票据”发给Alice，而Alice仅仅转发给Bob，而不是KDC给Bob呢？因为，如果这个票据先行到达Bob处，Bob就必须记住密钥Kab，直到需要使用这个密钥的时候。

# 有线等效保密协议（Wired Equivalent Privacy，WEP)
目标：使无线局域网WLAN拥有和有线局域网LAN一样的安全行。

在WEP协议中，无线接入点与所有用户共享单独的对称密钥。虽然在多个用户之间共享密钥的做法不是理想选择，但是会简化接入点的操作。WEP的认证过程就是简单的challenge-response
![](pic/WEP.png)

一旦Alice通过认证，数据包就会被加密，用RC4流加密方案。每个数据包使用密钥Kiv=(IV，K)进行加密。IV是3个字节的初始化向量，明文形式与数据包一起发送。由于IV只有3字节，密钥K又极少变化，加密密钥Kiv会经常出现重复，会令攻击变得容易。

## WEP协议的不完整性
WEP使用循环冗余校验CRC来进行完整性保护。攻击者可以在修改数据内容的同时修改CRC。应该采用MAC、HMAC、数字签名。

替代：WPA协议和WPA2协议


# GSM
![](pic/GSM.png)
- air interface 手机到基站的无线传输通信接口
- visited network 包括多个基站和一个基站控制器Base Station Controller。基站控制器扮演连接器的作用，将其控制下的基站与GSM网络其余部分连接起来。基站控制器包含了访问位置寄存器Visitor location registry，用于保存网络中所有当前处于活动状态的手机用户信息。
- 公用交换电话网Public Switched Telephone Network，指传统的（非蜂窝）电话网络系统，也称作陆地线路，与无线网络区分。
- Home Network归属地网络，手机注册的那个网络，每个手机都与唯一的HomeNetwork关联，Home Network包含了归属位置寄存器Home Location Registry，保存其列表中所有手机的最近位置的更新情况。鉴权中心Authentication Center主要维护关键性计费信息（IMSI和Ki）。

SIM卡中包含国际移动用户识别码IMSI，用于标识一台手机。SIM卡中还包含128位密钥Ki，只有手机及其归属地网络知道。

## GSM身份认证
challenge-response机制。基站收到通话发起者的IMSI后，将其传送给通话发起者的归属地网络。归属地网络生成随机challenge，RAND，同时计算出期望的response，XRES = A3（RAND,Ki）,A3是哈希函数。然后将(RAND,XRES)发送给基站。基站再将RAND发送给手机。手机计算response，发给基站，基站比较结果。

## GSM机密性
当归属地网络接收到从基站控制器发送过来的IMSI时，会计算加密密钥Kc = A8(RAND,Ki),其中A8时另外一个哈希函数，然后发送给基站(RAND,XRES,Kc)。基站接受到这个三元组后，启用签名描述的认证协议，如果认证成功，手机将会计算得到Kc。而基站已经知道了Kc，所以手机和基站之间有了共享的对称密钥，用于接下来的通话加密。数据加密使用A5/1流加密方案。
![](pic/GSM-1.png)

## 缺陷
哈希运算A3、A8都是基于COMP128的哈希函数，强度不高。

身份认证不是双向的，可以伪造基站。

## 3GPP
3GPP包含双向认证，并且对所有的信号实施完整性保护，包括基站向手机发送的“开始加密”命令的通信，消除了GSM类型的伪造假冒基站攻击。3GPP中密钥不能够被重用，COMP128这些被替换称KASUMI。数据加密从手机端全方位扩展到基站控制器一端。






